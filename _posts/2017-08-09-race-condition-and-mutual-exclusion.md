---
layout: post
title: "Race Condition and Mutual Exclusion"
date: 2017-08-09 01:14:01
author: "Wei SHEN"
categories: ["operating system"]
tags: ["concurrency"]
description: >
---

### 几个重要概念

### 竞态条件（Race Condition）
系统中协作的进程共享一些彼此都能读写的公共存储区，就会形成竞态条件。实际上竞态条件在线程上更普遍，因为线程间共享地址空间。

### 互斥（mutual exclusion)
以某种手段确保当一个进程再使用一个共享数据是，其他进程不能同时读写共享数据。

### 临界区域（critical region）
我们把对共享内存进行访问的 **程序片段** 成为临界区域。


### 忙等待互斥
忙等待互斥是最显而易见的一种互斥。用大白话说，**就是A在读写共享数据，B就等他**。

#### 最朴素直白的 **自旋锁(spin lock)**
忙等最朴素的方法就是 **用一个循环，始终不让程序进入到下一步**。

```c
// 进程A
while (TRUE) {
    while (turn != 0) {}   // 忙等循环
    critical_rigion();
    turn = 1;
    noncritical_rigion();
}
```

```c
// 进程B
while (TRUE) {
    while (turn != 1) {}    // 忙等循环
    critical_rigion();
    turn = 0;
    noncritical_rigion();
}
```

#### Peterson锁
也是用一个循环忙等。但加入了 **后来者惩罚机制**。

#### TSL指令
一个硬件支持的方案。一条特殊的指令 **测试并加锁（Test and Set Lock）**，将检查变量值和加锁动作原子化。确保至少这个原子化的动作是不可中断的。硬件层面就是在锁定内存总线。

为什么要把 **测试** 和 **加锁** 操作合并起来原子化呢？

因为互斥最容易想到的办法就是加 **状态锁**。在访问共享资源前检查资源状态锁的状态，如果已经被占用则等待。但单纯的状态锁除非代码像自旋锁这样严格轮换，否则如果在A进程检查过资源可用以后进程立即被挂起，B进程占用资源，再切换回A进程，A进程以为已经检查过资源可用，就直接使用，这就还是发生冲突。所以关键就是确保检查过状态之后，立即加锁，不要给其他进程可乘之机。这就是TSL原子化机器指令的用意。

### 睡眠与唤醒
