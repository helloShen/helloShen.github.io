---
layout: post
title: "Race Condition and Mutual Exclusion(draft...)"
date: 2017-08-09 01:14:01
author: "Wei SHEN"
categories: ["operating system"]
tags: ["concurrency"]
description: >
---

### 几个重要概念

### 竞态条件（Race Condition）
系统中协作的进程共享一些彼此都能读写的公共存储区，就会形成竞态条件。实际上竞态条件在线程上更普遍，因为线程间共享地址空间。

### 互斥（mutual exclusion)
以某种手段确保当一个进程再使用一个共享数据是，其他进程不能同时读写共享数据。

### 临界区域（critical region）
我们把对共享内存进行访问的 **程序片段** 成为临界区域。


### 忙等待互斥
忙等待互斥是最显而易见的一种互斥。用大白话说，**就是A在读写共享数据，B就等他**。

#### 状态锁是不安全的
互斥最容易想到的办法就是加 **状态锁**。就是增设一个共享的 **锁变量**。`0`表示没有被占用，处于可用状态。`1`表示已经被占用。程序在进入临界区前先检查锁变量的值，看目标资源是否已被占用。

> 但状态锁在没有某些操作原子性保证的情况下，是不安全的。

原因就是如果在A进程检查过资源可用以后进程立即被挂起，B进程占用资源，再切换回A进程，A进程以为已经检查过资源可用，就直接使用，这就还是发生冲突。这就是后面为什么要引入 **TSL** 指令的原因。

#### 朴素的 **自旋锁(spin lock)** 是安全的
忙等最朴素的方法就是 **用一个循环，始终不让程序进入到下一步**。

```c
// 进程A
while (TRUE) {
    while (turn != 0) {}   // 忙等循环
    critical_rigion();
    turn = 1;
    noncritical_rigion();
}
```

```c
// 进程B
while (TRUE) {
    while (turn != 1) {}    // 忙等循环
    critical_rigion();
    turn = 0;
    noncritical_rigion();
}
```

#### Peterson锁
也是用一个循环忙等。但加入了 **后来者惩罚机制**。

#### TSL指令
一个硬件支持的方案。一条特殊的指令 **测试并加锁（Test and Set Lock）**，将检查变量值和加锁动作原子化。确保至少这个原子化的动作是不可中断的。硬件层面就是在锁定内存总线。

为什么要把 **测试** 和 **加锁** 操作合并起来原子化呢？前面说过 **状态锁** 是不安全的。关键问题就在于 `检查状态锁的状态`和`加锁`是两个分开的动作。如果A程序在检查完锁的状态，确认锁没有被占用，但还没来得及加锁的时刻被挂起了，之后B程序占用了锁，再回来A程序就会误以为锁还没有被占用。TSL原子化机器指令就是要把`检查状态锁的状态`和`加锁`两个动作合并为一个原子性的动作，不可以被中断。

所以，状态锁只有在`TSL`原子性指令的帮助下，才是安全的。



### 睡眠与唤醒
上面的自旋锁也好，Peterson锁也好，都是通过有条件的循环忙等来达到竞态条件下多进程（或线程）的和平相处。但缺点就是 **浪费CPU时间**。所以叫忙等嘛，一直占着CPU不断地问“好了吗，好了吗，好了吗”，其他进程进不来。

更好的办法是：
> 挂起（进入 **阻塞状态** ）无法进入临界区域的进程。

做这件事的系统调用就是 **sleep**。它将 **引起调用进程进入阻塞状态**，直到另外一个进程将其唤醒。 唤醒的这个系统调用叫 **wakeup**。 sleep和wakeup是一对非常重要的 **通信原语**。这里的 **原语** 是指由若干条机器指令完成的某个特定操作，特点是 **执行过程不可被中断，具有原子性**。

！注意，唤醒原语并 **没有直接把CPU让出来**，而只是 **使目标进程进入就绪状态，等待调度程序的调度**。wakeup的具体执行过程如下：
* 在该事件的等待队列中找到相应进程的PCB。
* 将其从等待队列中移出，并置其状态为就绪状态。
* 把该PCB插入就绪队列中，等待调度程序调度。

### 信号量
信号量就是把原本只有`0`和`1`占用和没有被占用两种状态，变成具有一个较大取值空间的变量。非常适合用来模拟多进程协作的 **缓冲区**。

假设互斥量的上限如果是`N`，
* `down`操作：检查信号量是否大于`0`。
    * 若`>0`：将其减`1`，并继续。
    * 若`==0`：进程睡眠。
* `up`操作：对信号量增加`1`。

**!注意**：要保证信号量安全，**检查数值，修改变量，以及可能发生的睡眠操作均必须为一个单一的，不可分割的原子操作**。

一个典型的互斥量的模拟场景，就是 **生产者-消费者** 模型。信号量在其中扮演的角色就是生产者和消费者之间的缓冲区。比如一个厨师是生产者，产生菜。服务生是消费者，端菜给顾客。那信号量模拟的就是厨房用来摆放做好的菜的大桌子。比方桌子最多能放`10`个菜，桌子放满了，厨子就休息（睡眠）不做菜了。等桌子空了，服务生就休息（睡眠）不端菜了 。

### 互斥量
互斥量就是简化版的信号量。只有`0`和`1`两个可能取值。只能表示 **被占用**，和 **未被占用** 两种状态。没有缓冲。

### Pthread中的互斥
POSIX标准定义的线程包叫`Pthread`，作为对线程的抽象服务。所以虽然C语言不是面向对象的，但系统层面的设计很多都是对具体对象的模拟。这里每个`Pthread`线程都包含一个标识符，一组寄存器和一组存储在结构中的属性。

`Pthread`提供了操作互斥量的函数：
![posix-mutex](/images/leetcode/thread-race-condition/posix-mutex.jpg)

提一下`pthread_mutex_lock`和`pthread_mutex_trylock`的区别。
* `pthread_mutex_lock`: 如果锁已被占用，阻塞调用者。
* `pthread_mutex_trylock`: 如果锁已被占用，将返回错误代码，不阻塞调用者。
