---
layout: post
title: "[Thinking in Java] Note: Chapter 1 - Introduction to Objects"
author: "Wei SHEN"
date: 2016-03-04 20:02:13
categories: ["java","thinking in java"]
tags: ["oop"]
description: >
  第一章算是对象性质的总览。权限，组合，继承，多态，重载，接口，泛型，都粗略地过了一遍。
---

### 摘要
第一章算是对象性质的总览。权限，组合，继承，多态，重载，接口，泛型，都粗略地过了一遍。

其中对象的内存控制部分，放到了第二章详细介绍。

### 第一章 对象导论

#### 访问权限
public, protected, private三种访问权限。还有一种defaut，没有定义的时候的默认状态。public和private不用讲了。前者是**鸡**，大家都能上。后者是**良家**，只有自家老公（类内）能上。**defaut是只有包内范围才可见**，所以这像什么呢？典型的**一楼一凤**啊，邻居也可上。那**protected定义是包（package）内，以及子类才能访问**。这又是什么？我觉得像**潘金莲**，不但是一楼一凤，西门庆能上，连小叔子武松也能上。

#### 类的复用
类复用最基本的姿势，**compositon** （组合）和**inherite**（继承）。不用讲了。

一直把Java当乐高积木玩，就是这个原因。一个经过良好封装，严格测试的类，可以随手拿来就用，不会增加系统重构的成本。这也是测试驱动开发的精髓。

#### 重载
>比起在一个子类中创建很多父类中没有的新方法，不如让父类本身就包含这些方法，子类只是在这基础上"overriding"（重载）父类中的这些方法。

这里作者没细讲为什么。但我一般写代码，放一个空空如也的父类在哪儿，也不太美观吧。而且大部分事物都有一个主流方案，能解决80%情况下的问题，这样放在父类里，只有剩下20%的子类才需要重载。

#### 一个工程上的小问题
>设计中经常遇到的问题，原先设计的"制冷系统"类，当加上了"热力泵"之后，还叫"制冷系统"合适吗？

我自己编程时候经常改名。
![hotPot](/images/tij4-1/hotPump.png)

#### 多态以及后期绑定
>OOP最重要的妙诀：**polymophism（多态）**在编译的时候，不会绑定具体的函数调用。这里有一个简单的鸟的例子。多态调用**bird.move()**的时候，编译器不知道调用的是**鹅的飞**，还是**企鹅的走**。所以Java在编译的时候是**Late Binding**。

至于late banding的实现原理，书里没说，其实不难理解，我留作一个课后问题，去查资料。
![goose](/images/tij4-1/goose.png)

#### 单根继承
>singly rooted hierarchy。java的**单根继承特性**。最直观的好处就是每个object都能确定他的类型了，这样**垃圾回收**的的实现就容易很多。Java所有对象的超级父类是：Object。

对编程的的限制，因为可以用多个**Interface(接口)**来实现多继承，所以就不是问题了。接口和虚拟类的区别是一个老生常谈的问题。单根继承就是两者的根本区别，父类只能有一个，不管是不是虚拟类，但接口可以有很多个。

##### 引申出"接口"和"抽象类"的问题
**抽象类**最重要的几个属性：
1. 是父类就只能**单根继承**。
2. **不一定要实现**，可以只声明抽象方法在里面。**虚**就虚在这里。但也可以放具体方法实现，和具体变量。抽象类的子类也一样，如果没有实现全部方法，也只能是抽象类。
3. **不能直接实例化**。虚也有虚的代价。抽象类没有实现所有方法，所以写不出一个实例。但可以通过他的实体子类来实例化。
比如，抽象类Person，有一个实体子类Student。我们就可以通过多态来创建一个Person P。
```java
Person P = new Student ("Wei SHEN", "Computer Science");
```

**接口**的几个最重要的属性：
1. 接口不是类，接口是某种"**规格**"。因此一个类**可以符合多个接口**。
2. 实现某个接口的类，**必须实现接口中规定的所有"规格"**。这"规格"具体就是"方法"和"属性"。
3. 接口中规定的**方法不能具体实现**，但可以有静态属性值。
3. 接口中的方法自动是public的，属性也总是public static final的。不能自己定义。

#### 容器
这问题太大了，什么set,list,array list,linked list,map,hash map，等等等等。撸算法的时候要一个一个撸过来。

但一定要清楚的是，Java是一种强类型语言，Java有且只有**八种基本类型**：四种整型，两种浮点数字形，一种字符类型，以及一种布尔型。所谓基本类型，就是说他们统统不属于所谓的容器的范畴，甚至和所有的"对象"都有本质的区别。Java口口声声说"**一切皆是对象**"，实际上这八种基本类型是例外。以后会做详细介绍。这里只需要对他们"另眼相看"一下。
1. 四种整型：
	1. int： 4字节 （32比特，1字节=8比特）
	2. short： 2字节
	3. long： 8字节
	4. byte（字节）： 1字节（1字节=8比特。表示范围-128到127。）
2. 两种浮点型（包含小数部分）：
	1. float： 4字节
	2. double： 8字节
3. 字符型： char
4. 布尔型：**`true`** or **`false`**

#### 泛型
由容器引发的血案，就是当我创建一个容器比如说ArrayList myList的时候，原始（J2SE5以前）的做法是容器内的内容都只能指向通用类型"object"。但从J2SE5开始，引入**泛型**特性之后，我们可以指定容器内的类型：
```java
//!!!注意: 泛型的<T>类型只能是对象，不能是基本型，比如int,float之类。必须用他们的包装类Integer，Float，等。
ArrayList<shape> shapeList = new ArrayList<shape> ();
```
C++里这个特性叫"template"。

#### 堆和堆栈
垃圾回收是个大话题，但它引申出的"**堆(heap)**"和"**堆栈(steak)**"的问题也是个老话题。值得回顾一下。

原本写在这第一章里的，但第二章专门讲了内存的问题，就系统性地挪到第二章了。参见[**"Think in Java 读书笔记：第二章 - 一切都是对象"**](http://www.ciaoshen.com/2016/03/06/tij4-2/)。

#### 垃圾回收
关于垃圾回收的问题，因为和其实也就是内存管理的事，所以一起放到第二章，传送门[**"Think in Java 读书笔记：第二章 - 一切都是对象"**](http://www.ciaoshen.com/2016/03/06/tij4-2/)。

#### 关于web的话题
后面这部分就当看小说吧，而且故事挺好看的。看得出作者对Java满满的都是爱。尽管现实是applet在实际应用上和javascript完全不在一个级别上，还是能看出作者对applet的惋惜以及对javascript的不屑。虽然我不太理解作者对javascript的理解出于什么样的原因。从现在javascript+node.js的发展来看，完全可以和传统的LAMP（Linux+Appache+Mysql+Php）架构抗衡啊。本人用的这个Hexo博客框架就是基于node.js开发的。完全木有javascript要退出历史舞台嘛，反而越来越有活力的赶脚。反而是applet，之前自己开发一个web service应用的时候用到过applet+jsp的框架。但替代解决方案不要太多。至于作者自己都承认了，IE没有绑定applet基本等于宣判死刑了。当然我没有公司工作的经验，眼界很小，可以当我是放屁。

#### 关于服务器编程
扯这么大一段客户端编程，实际情况是服务器端编程才是主流吧。前段时间刚看了《黑客与画家》，没来的及写读后感。但里面对把应用全部移到服务器端构想和实践的描述，已经理想照进现实了好吗。我眼界小，但再小也知道前几年开始云端服务很热。云服务肯定不是说简单一个云网盘，想想Amazon这几年怎么从一个卖书网站蜕变成现在的江湖地位。还有现在很火的大数据，只有怪兽级服务器才能搞定。浏览器到底还只是个窗口而已，不能要求太多了。

### 扩展阅读

#### 后期绑定
