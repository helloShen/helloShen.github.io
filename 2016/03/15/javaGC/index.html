<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="CMS,G1,GC,JVM,PS,garbage collection,mark copy,mark sweep,memory,old generation,young generation," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="垃圾回收垃圾回收这点事儿，从第三章开始一直拖到现在都没有整理，作者并没有打算展开说这段，网上的资料要么含糊不清，要么就太细致，看着费劲。直到今天看到了这篇文章，《Java垃圾回收机制》（简书作者：可文分身），深入浅出，有图有真相。再结合比如这篇IBM的《Java内存详解》我对Java的垃圾回收机制有了一个基本的了解。我这里简单搬运一点，方便自己以后查阅。下文部分内容引用自以上两篇文章。感谢原作者可">
<meta property="og:type" content="article">
<meta property="og:title" content="Java垃圾回收初探">
<meta property="og:url" content="www.ciaoshen.com/2016/03/15/javaGC/index.html">
<meta property="og:site_name" content="沈玮 | Wei SHEN">
<meta property="og:description" content="垃圾回收垃圾回收这点事儿，从第三章开始一直拖到现在都没有整理，作者并没有打算展开说这段，网上的资料要么含糊不清，要么就太细致，看着费劲。直到今天看到了这篇文章，《Java垃圾回收机制》（简书作者：可文分身），深入浅出，有图有真相。再结合比如这篇IBM的《Java内存详解》我对Java的垃圾回收机制有了一个基本的了解。我这里简单搬运一点，方便自己以后查阅。下文部分内容引用自以上两篇文章。感谢原作者可">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/javaMemory.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/java_memory.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/jvm2.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/generation.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/gc-roots.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/StackVsHeap.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/mark_sweep.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/youngGeneration.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/oldGeneration.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/PSvsCMS.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/g1.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/g1Young.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-5/g1Old.png">
<meta property="og:updated_time" content="2016-03-15T19:50:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java垃圾回收初探">
<meta name="twitter:description" content="垃圾回收垃圾回收这点事儿，从第三章开始一直拖到现在都没有整理，作者并没有打算展开说这段，网上的资料要么含糊不清，要么就太细致，看着费劲。直到今天看到了这篇文章，《Java垃圾回收机制》（简书作者：可文分身），深入浅出，有图有真相。再结合比如这篇IBM的《Java内存详解》我对Java的垃圾回收机制有了一个基本的了解。我这里简单搬运一点，方便自己以后查阅。下文部分内容引用自以上两篇文章。感谢原作者可">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>



  <meta name="baidu-site-verification" content="3iRy3UFlpa" />


<script>
  (function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


  <title> Java垃圾回收初探 | 沈玮 | Wei SHEN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-74473715-1', 'auto');
  ga('send', 'pageview');
</script>







  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">沈玮 | Wei SHEN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Coder & Designer</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'hDG3wYskg4CYKGSXw8x7','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java垃圾回收初探
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-03-15T15:43:44-04:00" content="2016-03-15">
              2016-03-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
            <span id="busuanzi_container_page_pv">&nbsp; |  &nbsp; &nbsp; Viewed <span id="busuanzi_value_page_pv"></span> times</span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收这点事儿，从第三章开始一直拖到现在都没有整理，作者并没有打算展开说这段，网上的资料要么含糊不清，要么就太细致，看着费劲。直到今天看到了这篇文章，<a href="http://www.jianshu.com/p/778dd3848196" target="_blank" rel="external"><strong>《Java垃圾回收机制》（简书作者：可文分身）</strong></a>，深入浅出，有图有真相。再结合比如这篇IBM的<a href="https://www.ibm.com/developerworks/cn/java/j-nativememory-linux/" target="_blank" rel="external"><strong>《Java内存详解》</strong></a>我对Java的垃圾回收机制有了一个基本的了解。我这里简单搬运一点，方便自己以后查阅。下文部分内容引用自以上两篇文章。感谢原作者<a href="http://www.jianshu.com/users/a659b9c03f3e/latest_articles" target="_blank" rel="external"><strong>可文分身</strong></a>以及<a href="https://www.linkedin.com/in/andy-hall-a3a34720" target="_blank" rel="external">Andrew Hall</a>。</p>
<h4 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h4><p>故事是这样的，我们先从宏观的角度一点点往下捋。先看下面这张图。<br><img src="/uploads/tij4-5/javaMemory.png" alt="javaMemory"><br>从机器层面讲，<strong>操作系统和C-运行时库</strong>肯定本身就占一部分内存。然后当Java运行的时候，Java SE都会拥有一个<strong>逻辑堆</strong>。这个逻辑堆的大小可以在 Java 命令行使用 -Xmx 和 -Xms 选项来控制（mx 表示堆的最大大小，ms 表示初始大小）。这个堆主要是用来存放对象实例的，所以也可以叫<strong>对象堆</strong>。JVM虚拟机占的内存当然不包括在这个堆的范围里，而是在剩下的本地堆另外开辟的，再加上本地码，栈这些七零八碎的空间，姑且统称JVM区。所以宏观地讲，内存就被分成四大块：1）系统区 2）JVM区 3）Java逻辑堆区 4）本地堆。然后我们再看下面这张图。<br><img src="/uploads/tij4-5/java_memory.png" alt="java_memory"><br>这张图里<strong><code>Java process heap</code></strong>代表的是Java程序占用的总内存。也就是JVM区和Java逻辑堆区加起来。然后下面的<strong><code>Java object heap</code></strong>代表的就是逻辑堆区（也叫对象堆）。剩下的<strong><code>Everthing Else</code></strong>实际上相当于JVM区。这里面包含了这样几个很重要的东西。</p>
<p>首先要指出，这个<strong><code>Metaspace</code></strong>传统意义上讲是原来是逻辑堆里的<strong><code>Permanent Generation（永生代）</code></strong>，只是从Java7开始把它拿出来，大部分归到了本地堆的JVM区里了。这个永生代基本等价于<strong>方法区</strong>。<br>剩下传统意义的JVM区内存，首当其冲就是堆栈Stack。之前就讲过每个 Java 线程都需要堆栈空间来运行。一些常量，对象的引用，基本型，进程元数据等放在Stack堆栈区，这个堆栈区就在本地堆的JVM区里。然后JVM虚拟机里的即时 (JIT) 编译器编译时的输入（字节码）和输出（本地码）必须也存储在本机内存中。也就是上图中的<strong><code>Native Code</code></strong>。然后我们今天的主角垃圾回收器（<strong>GC</strong> Garbage Collection）使用的也是本地堆的内存。然后像类加载器，以及<strong>JNI</strong>（支持本机代码，使用 C 和 C++ 等本机编译语言编写的应用程序调用 Java 方法，反之亦然。）也要使用本地堆的内存。</p>
<p>下面另一张图，又是另外一种归纳方法，把Java内存主要分成三大块：逻辑堆，方法区和本地区。逻辑堆储存程序运行过程中产生的对象实例。方法区存放类的数据，包括字段，方法以及构造函数等。剩下的本地区包括stack栈区，机器码存放区，以及JVM各部件使用的内存等。其实和上面几张图说的都是一件事。都能找到一一对应关系。我们今天的主角<strong>垃圾回收器（GC）</strong>在Native Area，属于JVM的一部分。那这个被回收的垃圾就实例化的对象都存储在<strong>逻辑堆</strong>区。<br><img src="/uploads/tij4-5/jvm2.png" alt="jvm2"></p>
<h4 id="逻辑堆（对象堆）的结构"><a href="#逻辑堆（对象堆）的结构" class="headerlink" title="逻辑堆（对象堆）的结构"></a>逻辑堆（对象堆）的结构</h4><p>如下图所示，逻辑堆分成<strong>“年轻代”</strong>和<strong>“老年代”</strong>两部分。如果再加上被分离到方法区，存放类的元信息的<strong>“永生代”</strong>，总共3部分。而年轻代又分为两种，一种是<strong>“Eden”</strong>区域，另外一种是两个大小对等的Survivor区域：<strong>from区</strong>和<strong>to区</strong>。这名字其实很形象，因为年轻代存放的都是新近创建的对象。一个新对象的内存分配都在年轻代，具体地说是在年轻代的Eden区域。而老年代的实例年龄就要大很多，而且比年轻代的实例更稳定。之所以将Java内存按照分代进行组织，主要是基于这样一个事实：<strong>大多数对象都在年轻时候死亡</strong>。所以年轻代相对老年代需要更频繁的清理。把他们区分开来，配用不同的清理策略，有助于提高效率。<br><img src="/uploads/tij4-5/generation.png" alt="generation"></p>
<h4 id="年轻代垃圾回收"><a href="#年轻代垃圾回收" class="headerlink" title="年轻代垃圾回收"></a>年轻代垃圾回收</h4><p>在年轻代上，Java的垃圾回收使用的是<strong>Mark-Copy</strong>算法。顾名思义，算法分成<strong>Mark</strong>和<strong>Copy</strong>两个步骤。Mark指的是标记出所有还活着的实例，然后清扫掉所有未被标记的实例，空出内存，实际这个过程叫做<strong>Mark-Sweep</strong>算法（详见<a href="http://www.jianshu.com/p/b0f5d21fe031" target="_blank" rel="external">“<strong>标记-清扫算法</strong>“</a>这篇文章）。然后Copy部分就是将幸存的不同年龄的实例拷贝到别的分代。下面我们就对这两个过程一一讲解。</p>
<h5 id="标记存活实例"><a href="#标记存活实例" class="headerlink" title="标记存活实例"></a>标记存活实例</h5><p>讲到垃圾回收，我们的第一反应一定是怎么标记垃圾。比如最简单的区分技术：<strong>引用计数(reference conunting)</strong>。每个对象都含有一个引用计数器。当有引用指向对象时，计数器加一。引用脱钩，计数器减一。但这个方法有个缺陷，想想看两个对象互相引用，但实际上他们已经脱离全世界的情况，他们各自的计数器都不是零。所以这种方法几乎很少被使用。</p>
<p>Java垃圾回收使用的策略恰好相反，是标记所有存活的实例，其他的全部清除。考虑到”大多数对象都在年轻时死亡”这个事实，搜索活着的比搜索死去的更省事儿。从下图中，我们可以看到Java是从所谓的<strong>“根对象”</strong>开始地毯式扫描，遍历所有和根对象有直接或间接引用关系的实例。<br><img src="/uploads/tij4-5/gc-roots.png" alt="gc-roots"></p>
<p>那关键问题是，哪些对象是<strong>“根对象”</strong>呢？根据<a href="http://www.dynatrace.com/en/javabook/how-garbage-collection-works.html" target="_blank" rel="external">“<strong>How Garbage Really Works</strong>“</a>这篇文章，根对象主要包括四类对象：</p>
<ol>
<li><strong>stack栈中引用的对象</strong>：这主要指main方法中产生的储存在JVM栈中的对对象的引用。以前已经分析过，java对象都存在heap区，对对象的引用都存在stack区。GC会去找当前stack区里还留有的main方法产生的引用。这是我们实例最主要的来源。下面这张图非常地形象。因为栈里的引用的生命周期都和他在代码里的作用域挂钩，比如说出了括号，括号里声明的引用就会从stack里擦除，跟着的一大串对象就再也不可能被标记到了。<img src="/uploads/tij4-5/StackVsHeap.png" alt="StackVsHeap"></li>
<li><strong>static静态变量</strong>：静态方法和变量不产生实例，直接由类引用。Java的类由<strong><code>java.lang.ClassLoader</code></strong>类加载器加载，类的数据都不在逻辑堆，而是存在永生代，也就是Method Area方法区，现在叫Metaspace。类本身一旦被GC清除，他的所有静态变量也就跟着被释放了。</li>
<li><strong>main thread</strong>：main方法就是一个thread线程。java里线程也都是继承自基类，所以自身也是一个大实例。</li>
<li><strong>JNI引用</strong>：JNI是支持其他编程语言的本机码和Java字节码互相调用的程序。除了Java进程内部的调用，JVM还需要知道一个实例是否被外部本机代码所调用，JNI引用就列举了当前的外部调用。</li>
</ol>
<p>所以我们总结一下Mark-Sweep算法（转自<a href="http://www.jianshu.com/p/b0f5d21fe031" target="_blank" rel="external">“<strong>标记-清扫算法（简书作者：可文分身）</strong>“</a>）：<br>在标记阶段，mutator先中断整个程序的运行（Stop-The-World的称呼由此而来）。然后collector从根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。然后清除阶段，collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。在清除完成以后，mutator在回复程序的运行。<br><img src="/uploads/tij4-5/mark_sweep.png" alt="mark_sweep"></p>
<h5 id="拷贝到其他代区"><a href="#拷贝到其他代区" class="headerlink" title="拷贝到其他代区"></a>拷贝到其他代区</h5><p>如下图1所示，新对象的内存分配先分配在Eden区域，当Eden区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收（发生在Eden和Survivor内存区域上），我们称之为<strong>“Minor Garbage Collection”</strong>。 同时，每个对象都有一个<strong>“年龄”</strong>，这个年龄实际上指的就是该对象经历过的minor gc的次数。如图1所示，当对象刚分配到Eden区域时，对象的年龄为“0”，当minor gc被触发后，所有存活的对象（根据前面的Mark-Sweep算法）会被拷贝到其中一个Survivor区域，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。<br><img src="/uploads/tij4-5/youngGeneration.png" alt="youngGeneration"><br>当第二次minor gc被触发时（如图2所示），JVM再次通过Mark算法找出所有在Eden内存区域和Survivor1内存区域存活的对象，并将他们拷贝到新的Survivor2内存区域(这也就是为什么需要两个大小一样的Survivor区域的原因，两个区被交替使用，确保其中一个全空)，同时对象的年龄加1. 最后，清除所有在Eden内存区域和Survivor1内存区域的非可达对象。</p>
<p>当对象的年龄足够大（这个年龄可以通过JVM参数进行指定，这里假定是2），当minor gc再次发生时，它会从Survivor内存区域中升级到年老代中，如图3所示。其实，即使对象的年龄不够大，但是Survivor内存区域中没有足够的空间来容纳从Eden升级过来的对象时，也会有部分对象直接升级到Tenured内存区域中。</p>
<h4 id="老年代垃圾回收"><a href="#老年代垃圾回收" class="headerlink" title="老年代垃圾回收"></a>老年代垃圾回收</h4><p>当minor gc发生时，又有对象从Survivor区域升级到Tenured区域，但是Tenured区域已经没有空间容纳新的对象了，那么这个时候就会触发年老代上的垃圾回收，我们称之为<strong>“Major Garbage Collection”</strong>.<br>而在年老代上选择的垃圾回收算法则取决于JVM上采用的是什么垃圾回收器。通过的垃圾回收器有两种：<strong>Parallel Scavenge(PS)</strong> 和<strong>Concurrent Mark Sweep(CMS)</strong>。他们主要的不同体现在年老代的垃圾回收过程中，年轻代的垃圾回收过程他们都使用前文分析的Mark-Copy算法。顾名思义，Parallel Scavenge垃圾回收器在执行垃圾回收时使用了多线程，以提高垃圾回收的效率。而Concurrent Mark Sweep回收器主要是应用程序挂起”Stop The World”的时间比较短，更接近并发。</p>
<h5 id="Parallel-Scavenge算法"><a href="#Parallel-Scavenge算法" class="headerlink" title="Parallel Scavenge算法"></a>Parallel Scavenge算法</h5><p>和Mark-Copy算法不同，PS算法在执行的是<strong>Mark-Compact</strong>过程。Mark还是之前的mark-sweep过程，标记存活实例，清除不可达实例。不同的是没有一个预留的survivor区来全部拷贝过去。主要是考虑到老年代比较稳定，也比较大，全部拷贝效率上划不来。但问题是空间会碎片化，以后大一点的对象存不进来。所以要来一个compact碎片整理。<br><img src="/uploads/tij4-5/oldGeneration.png" alt="oldGeneration"></p>
<h5 id="Concurrent-Mark-Sweep"><a href="#Concurrent-Mark-Sweep" class="headerlink" title="Concurrent Mark Sweep"></a>Concurrent Mark Sweep</h5><p>前面讲了，CMS主要特点是并发，Stop-The-World时间短。从他的名字可以看出，他的主要思想还是源于Mark-Sweep。下面看看他的并发具体是怎么实现的。<br><img src="/uploads/tij4-5/PSvsCMS.png" alt="PSvsCMS"></p>
<ol>
<li><strong>Initial Mark阶段</strong>： 这个阶段还是Stop-The-World的，会挂起程序。但和普通Mark的区别是：它从”根对象”出发，标记到根对象的第一层子节点即停止，马上恢复应用程序的运行。所以程序暂停时间短。</li>
<li><strong>Concurrent Mark阶段</strong>： 在这个阶段中，从Initial Mark阶段标记的一代子节点开始标记Tenured区域中所有可达对象。当然，在这个阶段中是不需要暂停程序的。这也是它称为”Concurrent Mark”的原因。</li>
<li><strong>Remark阶段</strong>： 但Concurrent Mark和应用程序同时运行的问题是：应用程序一直在分配新对象。所以Concurrent Mark阶段它并不保证所有在Tenured区域的可达对象都被标记了。所以我们需要再次暂停应用程序，再从根节点开始补漏，确保所有的可达对象都被标记。因为老年代比较稳定，一般漏掉的不会太多，所以Remark阶段挂起时间也比较短。</li>
<li><strong>Concurrent Sweep阶段</strong>： 最后，恢复应用程序的执行，同时CMS执行sweep，来清除所有非可达对象所占用的内存空间。</li>
</ol>
<p>所以实际上CMS就是节省了从跟对象一代子对象往下搜索全部可达对象的时间。但CMS有个明显的缺点，就是他没有碎片整理的过程。对空间的利用不好，容易引发out of memory。</p>
<h4 id="Garbage-First-G1-垃圾收集器"><a href="#Garbage-First-G1-垃圾收集器" class="headerlink" title="Garbage First(G1)垃圾收集器"></a>Garbage First(G1)垃圾收集器</h4><p>针对CMS这个没有碎片整理的问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器 - <strong>Garbage First(G1)垃圾收集器</strong>。</p>
<p>G1垃圾收集器和CMS垃圾收集器有几点不同。首先，最大的不同是内存的组织方式变了。Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了下图中一个个大小一样的region - 每个region从1M到32M不等。<br><img src="/uploads/tij4-5/g1.png" alt="g1"><br>一个region有可能属于Eden，Survivor或者Tenured内存区域。图中的E表示该region属于Eden内存区域，S表示属于Survivor内存区域，T表示属于Tenured内存区域。图中空白的表示未使用的内存空间。G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。这种内存区域主要用于存储大对象-即大小超过一个region大小的50%的对象。前文也介绍了，原先的PermaGene永生代被移到了本地堆，作为Metaspace独立存在。区隔变小的</p>
<p>在G1垃圾收集器中，年轻代的垃圾回收过程跟PS垃圾收集器和CMS垃圾收集器差不多，新对象的分配还是在Eden region中，当所有Eden region的大小超过某个值时，触发minor gc，回收Eden region和Survivor region上的非可达对象，同时升级存活的可达对象到对应的Survivor region和Tenured region上。对象从Survivor region升级到Tenured region依然是取决于对象的年龄。<br><img src="/uploads/tij4-5/g1Young.png" alt="g1Young"><br>对于年老代上的垃圾收集，G1垃圾收集器也分为4个阶段，基本跟CMS垃圾收集器一样，但主要的改进有一下几项：</p>
<ol>
<li><strong>多了Clean up/Copy阶段</strong>： 在G1中，没有CMS中对应的Sweep阶段。相反 它有一个Clean up/Copy阶段。现在G1里，老年代也像年轻代一样标记清扫之后要重新拷贝到新的region里去了。这样划分小区隔region的好处就是，不同代区的转化分配更自由合理了。</li>
<li><strong>更高的并发性</strong>： 同CMS垃圾收集器的Initial Mark阶段一样，G1也需要暂停应用程序的执行，也只标记根对象的第一层孩子节点中的可达对象。但是G1的垃圾收集器的Initial Mark阶段和Clean up/Copy阶段是跟minor gc一同发生的，在G1触发年轻代minor gc的时候聪明地一并将年老代上的Initial Mark给做了。</li>
<li><strong>搜索的同时回收</strong>：在Concurrent Mark阶段中，发现哪些Tenured region中对象的存活率很小或者基本没有对象存活，那么G1就会在这个阶段将其回收掉，而不用等到后面的clean up阶段。这也是Garbage First名字的由来。这样小region设计的好处也出来了，整个系统显得更加灵活。包括上文提到的Humongous内存区域，大对象单独占一个区，可以单独特殊处理，效率更高。</li>
<li><strong>新Remark算法SATB</strong>：因为Initial Mark阶段的程序挂起现在在minor gc的时候顺便做掉了，G1在处理老年代的时候唯一还需要挂起的就是Remark补漏阶段。所以G1采用了一种叫SATB(snapshot-at-the-begining)的算法能够在Remark阶段更快的标记可达对象。</li>
</ol>
<p><img src="/uploads/tij4-5/g1Old.png" alt="g1Old"></p>
<p>所以综合来讲，G1加上了CMS没有的碎片整理功能，同时程序挂起时间更短了，并发性更高了，而且存活对象的标记效率也更高了。目前G1正在全面替换掉CMS。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，我对Java垃圾回收器GC的原理做了一个简单的了解。我深深感受到系统过程设计的复杂度。所以当我们在愉快地编程的时候，JVM默默地为我们做了这么多的事。实际本文只是做一个草草的鸟览，文中所描述过程的真正复杂性还完全没有被揭示出来。事实上每一个对复杂性的掩盖，都凝聚着无数设计师深沉的思考。而这些深沉的思考才是我们人类进步最坚定有力的阶梯，至少比某些主义来的实用地多。我觉得它们很美。</p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CMS/" rel="tag">#CMS</a>
          
            <a href="/tags/G1/" rel="tag">#G1</a>
          
            <a href="/tags/GC/" rel="tag">#GC</a>
          
            <a href="/tags/JVM/" rel="tag">#JVM</a>
          
            <a href="/tags/PS/" rel="tag">#PS</a>
          
            <a href="/tags/garbage-collection/" rel="tag">#garbage collection</a>
          
            <a href="/tags/mark-copy/" rel="tag">#mark copy</a>
          
            <a href="/tags/mark-sweep/" rel="tag">#mark sweep</a>
          
            <a href="/tags/memory/" rel="tag">#memory</a>
          
            <a href="/tags/old-generation/" rel="tag">#old generation</a>
          
            <a href="/tags/young-generation/" rel="tag">#young generation</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/14/tij4-5/" rel="next" title="Think in Java 读书笔记：第五章 - 初始化与清理">
                <i class="fa fa-chevron-left"></i> Think in Java 读书笔记：第五章 - 初始化与清理
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/shenAvatar.jpg"
               alt="沈玮 | Wei SHEN" />
          <p class="site-author-name" itemprop="name">沈玮 | Wei SHEN</p>
          <p class="site-description motion-element" itemprop="description">Coder & Designer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/helloShen" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.douban.com/people/72441576/" target="_blank">
                  
                    <i class="fa fa-globe"></i> DouBan
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/pang-pang-37-37" target="_blank">
                  
                    <i class="fa fa-globe"></i> ZhiHu
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM的内存结构"><span class="nav-number">1.1.</span> <span class="nav-text">JVM的内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑堆（对象堆）的结构"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑堆（对象堆）的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#年轻代垃圾回收"><span class="nav-number">1.3.</span> <span class="nav-text">年轻代垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#标记存活实例"><span class="nav-number">1.3.1.</span> <span class="nav-text">标记存活实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝到其他代区"><span class="nav-number">1.3.2.</span> <span class="nav-text">拷贝到其他代区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老年代垃圾回收"><span class="nav-number">1.4.</span> <span class="nav-text">老年代垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge算法"><span class="nav-number">1.4.1.</span> <span class="nav-text">Parallel Scavenge算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Concurrent-Mark-Sweep"><span class="nav-number">1.4.2.</span> <span class="nav-text">Concurrent Mark Sweep</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Garbage-First-G1-垃圾收集器"><span class="nav-number">1.5.</span> <span class="nav-text">Garbage First(G1)垃圾收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.6.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沈玮 | Wei SHEN</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io" rel="external nofollow">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Mist
  </a>
</div>

</br>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div>
  <span id="busuanzi_container_site_pv">
  Visited  <span id="busuanzi_value_site_pv"></span>  times
  </span>

<span id="busuanzi_container_site_pv">&nbsp; &nbsp; | &nbsp; &nbsp;</span>

  <span id="busuanzi_container_site_uv">
  <span id="busuanzi_value_site_uv"></span>  Visitors
  </span>
<div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  

  
  


</body>
</html>
