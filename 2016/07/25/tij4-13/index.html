<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="regular expression,string,字符串,标准化输出,正则表达式," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="摘要这章讲平时最常用的String字符串。主要讲了一下几件事：

String的内部结构和特性
更高效的字符串构造工具StringBuilder
标准化输出“format”
正则表达式
正则表达式的应用Pattern和Matcher以及Scanner

StringString看似常用，其实越简单的东西往往越靠近底层。有很多隐藏起来的复杂性并没有被我们看到。
String到底是个什么？翻开JDK中">
<meta property="og:type" content="article">
<meta property="og:title" content="Think in Java 读书笔记：第十三章 - 字符串">
<meta property="og:url" content="www.ciaoshen.com/2016/07/25/tij4-13/index.html">
<meta property="og:site_name" content="沈玮 | Wei SHEN">
<meta property="og:description" content="摘要这章讲平时最常用的String字符串。主要讲了一下几件事：

String的内部结构和特性
更高效的字符串构造工具StringBuilder
标准化输出“format”
正则表达式
正则表达式的应用Pattern和Matcher以及Scanner

StringString看似常用，其实越简单的东西往往越靠近底层。有很多隐藏起来的复杂性并没有被我们看到。
String到底是个什么？翻开JDK中">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/oop_13.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/string.gif">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/stringImmutable.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-11/ArrayMemory1.jpg">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/memory6.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/flags.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/conversion.png">
<meta property="og:image" content="www.ciaoshen.com/uploads/tij4-13/receipt.png">
<meta property="og:updated_time" content="2016-08-01T23:34:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Think in Java 读书笔记：第十三章 - 字符串">
<meta name="twitter:description" content="摘要这章讲平时最常用的String字符串。主要讲了一下几件事：

String的内部结构和特性
更高效的字符串构造工具StringBuilder
标准化输出“format”
正则表达式
正则表达式的应用Pattern和Matcher以及Scanner

StringString看似常用，其实越简单的东西往往越靠近底层。有很多隐藏起来的复杂性并没有被我们看到。
String到底是个什么？翻开JDK中">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>



  <meta name="baidu-site-verification" content="3iRy3UFlpa" />


<script>
  (function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


  <title> Think in Java 读书笔记：第十三章 - 字符串 | 沈玮 | Wei SHEN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-74473715-1', 'auto');
  ga('send', 'pageview');
</script>







  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">沈玮 | Wei SHEN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Coder & Designer</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'hDG3wYskg4CYKGSXw8x7','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Think in Java 读书笔记：第十三章 - 字符串
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-25T15:07:18-04:00" content="2016-07-25">
              2016-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index">
                    <span itemprop="name">Note</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/25/tij4-13/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/25/tij4-13/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
            <span id="busuanzi_container_page_pv">&nbsp; |  &nbsp; &nbsp; Viewed <span id="busuanzi_value_page_pv"></span> times</span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/uploads/tij4-13/oop_13.png" alt="oop_13"></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>这章讲平时最常用的String字符串。主要讲了一下几件事：</p>
<ol>
<li>String的内部结构和特性</li>
<li>更高效的字符串构造工具StringBuilder</li>
<li>标准化输出“format”</li>
<li>正则表达式</li>
<li>正则表达式的应用Pattern和Matcher以及Scanner</li>
</ol>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String看似常用，其实越简单的东西往往越靠近底层。有很多隐藏起来的复杂性并没有被我们看到。</p>
<h3 id="String到底是个什么？"><a href="#String到底是个什么？" class="headerlink" title="String到底是个什么？"></a>String到底是个什么？</h3><p>翻开JDK中String的源码第一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** String本质是个char数组. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这告诉我们，String的本质是一个<strong>char[]字符数组</strong>。</p>
<p><img src="/uploads/tij4-13/string.gif" alt="string"><br>如上图所示，一个String由两部分组成：存放信息实体的字符数组<strong>char[]</strong>和管理这个char[]的<strong>元信息</strong>。我们以一个32位系统上含有8个字符的String为例，每个char32位，char[]纯信息一共128位。用来管理Array的元信息128位。所以整个char[]一共256位。另外String用来管理char[]的元信息一共244位。所以加在一起一共480位（60个字节）用来表示128位(16个字节，或者说8个字符)。</p>
<p>其中，String的三大元数据分别是，</p>
<ul>
<li><strong>hash</strong>：是用来记录已经计算好的本String的散列值。避免重复计算。初始值为零。</li>
<li><strong>count</strong>：是记录String的长度。也就是char[]的长度。</li>
<li><strong>offset</strong>：偏移值。顾名思义，用来在substring()取子字符串的时候标明偏移值。</li>
</ul>
<p>作为程序员在用数据的时候，起码要知道自己手上用的是个什么东西。</p>
<h3 id="String是不可变的，线程安全的"><a href="#String是不可变的，线程安全的" class="headerlink" title="String是不可变的，线程安全的"></a>String是不可变的，线程安全的</h3><p>关于String两个最基本的特性要记住，第一，<strong>String是不可变的</strong>。第二，<strong>String是线程安全的</strong>。</p>
<h4 id="什么是不可变？"><a href="#什么是不可变？" class="headerlink" title="什么是不可变？"></a>什么是不可变？</h4><p>String不可变很简单，如下图，给一个已有String第二次赋值，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。<br><img src="/uploads/tij4-13/stringImmutable.png" alt="stringImmutable"></p>
<h4 id="为什么String是不可变的？"><a href="#为什么String是不可变的？" class="headerlink" title="为什么String是不可变的？"></a>为什么String是不可变的？</h4><p>首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段<strong>value</strong>是个<strong>char[ ]</strong>数组，而且是用<strong>final</strong>修饰的。final修饰的字段创建以后就不可改变。有的人以为故事就这样完了，其实没有。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实。Array的数据结构看下图，<br><img src="/uploads/tij4-11/ArrayMemory1.jpg" alt="ArrayMemory1"><br>也就是说Array变量只是stack上的一个引用，数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。看下面这个例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] another=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">value=another;    <span class="comment">//编译器报错，final不可变</span></span><br></pre></td></tr></table></figure></p>
<p>value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，分分钟搞定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">2</span>]=<span class="number">100</span>;  <span class="comment">//这时候数组里已经是&#123;1,2,100&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>所以String是不可变，关键是因为SUN公司的工程师，在后面所有String的方法里很小心的没有去动Array里的元素，没有暴露内部成员字段。而且还很小心地把整个String设成final禁止继承，避免被其他人破坏。所以String是不可变的关键都在底层的实现，而不是一个final。考验的是工程师构造数据类型，封装数据的功力。</p>
<h4 id="不可变有什么好处？"><a href="#不可变有什么好处？" class="headerlink" title="不可变有什么好处？"></a>不可变有什么好处？</h4><p>这个最简单地原因，就是为了安全。但这个东西，仁者见仁。比如下面这个代码，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String s = <span class="string">"aaaa"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeStr</span><span class="params">(String inStr)</span></span>&#123;inStr=<span class="string">"bbbb"</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果一个变量当一次参数就变了，会有比较隐蔽的bug。但有的时候我们传参数就是为了变参数，这就很尴尬。</p>
<p>但下面这个HashSet的例子，就没人希望String是可变的了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">"aaaa"</span>;</span><br><span class="line">String sCp=s;</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hs=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hs.add(s);</span><br><span class="line"></span><br><span class="line">String sCp=<span class="string">"bbbb"</span>;</span><br></pre></td></tr></table></figure></p>
<p>两个字符串s和sCp都指向了同一个对象。当我们把s存入HashSet之后，如果没有不可变性的保护，无意间改变sCp的值可能就破坏了HashSet键值的唯一性。这也就是为什么String适合用来做有唯一性的键值的重要原因。</p>
<p>还有一个大家都知道，就是在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以线程安全。</p>
<p>最后别忘了String另外一个字符串常量池的属性。接下来正好要讲这个。Java之所以能实现这个特性，String的不可变性是最基本的一个必要条件。要是内存里字符串内容能改来改去，这么做就完全没有意义了。</p>
<h3 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h3><p>由于String是Java里最常用的数据类型之一，往往内存里会塞满了String，而且互相重复，数据冗余很高。为了避免内存臃肿，提高效率，java实现了一套基于<br>字符串常量池的优化方案。</p>
<p>用String Table驻留一个String对象的引用，每次要用到一个String字面量的时候，都会先查这个表。确定没有再创建，有的话就直接复制一个驻留引用。<br>String Table在哪儿？ 可以理解为过去说的Perm Generation 永生代里，方法区的外面。<br>原理这里不展开了，详细可以参看一篇专题：<a href="http://www.ciaoshen.com/2016/07/29/string/"><strong>《String str=new String(“Hello”)到底创建了几个对象？》</strong></a>。</p>
<p>这里我就贴一个简单的结论，方便以后查阅。更详细的例子，和解释都在上面这篇专题里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String staticStr=<span class="string">"Hello"</span>;</span><br><span class="line">	<span class="keyword">private</span> String memberStr=<span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String methodStr=<span class="string">"Hello"</span>;</span><br><span class="line">		System.out.println(methodStr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test t=<span class="keyword">new</span> Test();</span><br><span class="line">		t.sayHello();</span><br><span class="line">		String threadStr=<span class="string">"Hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，staticStr是Test类的静态成员变量，memberStr是普通成员变量。methodStr是sayHello方法的局部变量。在主线程方法main里，还有一个threadStr。<br><img src="/uploads/tij4-13/memory6.png" alt="memory6"><br>如上图所示，四个变量都指向堆区新生代里的同一个对象实例“Hello”。但程序运行过程里，内存里实际存在过6个对这个对象的引用。具体如下，</p>
<ol>
<li>首先方法区外面的字符串常量池有一个长期驻留引用。</li>
<li>第二，静态变量staticStr，理论上可以认为存在方法区的运行时常量池里。但就像您文章里测出来实际是在堆里，是因为不同JVM具体操作不同。</li>
<li>第三，memberStr是作为Test类的成员变量，存在堆里。</li>
<li>第四，methodStr变量存在栈区sayHello()方法的私有栈帧里的局部变量表。</li>
<li>第五，我们用System.out打印变量methodStr的时候，会有一个新的对“Hello”的引用被压到操作数栈里。但很快操作完就又弹出去了。</li>
<li>sayHello()函数运行完methodStr变量对“Hello”对象的引用就被释放。</li>
<li>第六个，主线程main里的threadStr变量也存在一个栈帧的局部变量表里。</li>
<li>最后程序运行完，除了字符串常量池里的驻留引用还继续生存，其他引用全部被释放。</li>
</ol>
<h3 id="不可变特性影响了String的效率"><a href="#不可变特性影响了String的效率" class="headerlink" title="不可变特性影响了String的效率"></a>不可变特性影响了String的效率</h3><p>String不可变的特性，影响了它的效率。比如“+”拼接字符串，因为String不可变，不可以直接在原字符串后面拼接，每次都需要重建一个新对象，来存放拼接后更长的字符串。拼接多次，中间生成的字符串就会成为垃圾，需要被回收。我们知道java的垃圾回收开销又很大。比如下面最简单的操作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>+<span class="string">"d"</span>+<span class="string">"e"</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果用笨办法拼接，最后为了得到“abcde”,java堆会产生”a”,”b”,”c”,”d”,”e”,”ab”,”abc”,”abcd”这么多中间对象，再算上垃圾回收的时间，真的会很慢。</p>
<h4 id="更高效的字符串构造工具StringBuilder"><a href="#更高效的字符串构造工具StringBuilder" class="headerlink" title="更高效的字符串构造工具StringBuilder"></a>更高效的字符串构造工具StringBuilder</h4><p>Java为了优化性能，设计了一个<strong>StringBuilder</strong>类，它是可变的。使得StringBuilder.append()方法拼接字符串，是直接在原字符串上拼接。不产生中间字符串，提高了效率。</p>
<p>那StringBuilder.append()是怎么做到不产生中间副产品字符串的呢？</p>
<p>因为StringBuilder是可变的。直接看源码，StringBuilder的基类AbstractStringBuilder数据容器char数组不是final的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></p>
<p>AbstractStringBuilder#append()方法直接调用String#getChars()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Documentation in subclasses because of synchro difference</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sb == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> append(<span class="string">"null"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sb.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        sb.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>而String#getChars()直接调用的是System.arrayCopy()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而System.arrayCopy()是一个本地方法，用Native关键字修饰。说明它的实现是调用本地系统的用C或者C++写的程序执行字符串的拼接。为了更高的效率。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span><br><span class="line">                                        Object dest, <span class="keyword">int</span> destPos,</span><br><span class="line">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个底层的arraycopy就先不管，只要知道它是一个效率比较高的直接拼接数组的函数就可以了。</p>
<h4 id="简单的String拼接真的这么慢吗？"><a href="#简单的String拼接真的这么慢吗？" class="headerlink" title="简单的String拼接真的这么慢吗？"></a>简单的String拼接真的这么慢吗？</h4><p>再回到String，还是开始的简单例子，”a”+”b”+”c”+”d”。实际我们执行下面的语句真的很慢吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String直接字面拼接：1308纳秒</span></span><br><span class="line">String result=<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>+<span class="string">"d"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder拼接：42920纳秒</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"a"</span>);</span><br><span class="line">sb.append(<span class="string">"b"</span>);</span><br><span class="line">sb.append(<span class="string">"c"</span>);</span><br><span class="line">sb.append(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String对象拼接：13774纳秒</span></span><br><span class="line">String a=<span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String b=<span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">String c=<span class="keyword">new</span> String(<span class="string">"c"</span>);</span><br><span class="line">String d=<span class="keyword">new</span> String(<span class="string">"d"</span>);</span><br><span class="line">String str=a+b+c+d;</span><br></pre></td></tr></table></figure></p>
<p>简单做个上面这个测试，结果是String字面量直接拼接耗时<strong>1308纳秒</strong>，而StringBuilder耗时为<strong>42920纳秒</strong>，String对象拼接：<strong>13774纳秒</strong>。</p>
<p>所以，真相是String类像这样简单地字面量的拼接操作也已经被优化过了，String result=”a”+”b”+”c”+”d”基本可以等同于String result=”abcd”。而且创建StringBuilder实例本身的开销也不小，区区几个字符的拼接，还体现不出它的价值，甚至还不够弥补它本身实例化的开销。</p>
<p>那什么规模能体现出StringBuilder的优势呢？ 下面我们把上面每个操作都重复了一万次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String直接字面拼接：105334355纳秒</span></span><br><span class="line">        String a=<span class="string">"a"</span>;</span><br><span class="line">        String b=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            b+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//StringBuilder拼接：415360纳秒</span></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            sb.append(<span class="string">"a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String对象拼接：198404867纳秒</span></span><br><span class="line">        String s=<span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            String x=<span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">            s+=x;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>再看结果：</p>
<ul>
<li>String直接字面拼接：    105334355    纳秒</li>
<li>StringBuilder拼接：    415360        纳秒</li>
<li>String对象拼接：        198404867    纳秒</li>
</ul>
<p>是不是StringBuilder的优势出来了？快了1000倍。为什么呢？因为由于for的循环结构，String拼接只能老老实实每次创建一个新对象了。JVM内部”+“加号操作符的红利就没有了。</p>
<p>所以，要记住下面这个结论：</p>
<blockquote>
<p><strong>简单的个别几个字符串拼接，还是用String直接拼接更快。如果有大量的字符串需要拼接，并且用到了loop循环控制流，这时候就是StringBuilder效率更高了。</strong></p>
</blockquote>
<h4 id="循环的时候，注意手动在循环外创建一个StringBuilder"><a href="#循环的时候，注意手动在循环外创建一个StringBuilder" class="headerlink" title="循环的时候，注意手动在循环外创建一个StringBuilder"></a>循环的时候，注意手动在循环外创建一个StringBuilder</h4><p>刚才实验也显示了，StringBuilder实例化的开销比单个String对象的创建开销大多了。所以用循环语句拼接的时候，注意要在循环域外先创建一个StringBuilder，否则每次循环都会创建一个新的StringBuilder。</p>
<p>下面这个代码，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&gt;)&#123;</span><br><span class="line">	s+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于以下操作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&gt;)&#123;</span><br><span class="line">	StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种循环拼接字符串的情况，还是手动在循环外面创建一个StringBuilder比较好，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&gt;)&#123;</span><br><span class="line">	sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="String-V-s-StringBuilder-V-s-StringBuffer"><a href="#String-V-s-StringBuilder-V-s-StringBuffer" class="headerlink" title="String V.s. StringBuilder V.s. StringBuffer"></a>String V.s. StringBuilder V.s. StringBuffer</h3><p>有了String和StringBuilder，为什么还要StringBuffer呢？</p>
<p>其实是人家StringBuffer先出来的好吗。StringBuilder是在Java1.5才加进来的。</p>
<blockquote>
<p>String 不可变 （线程安全） since JDK1.0<br>java.lang.String public final class String</p>
<p>StringBuffer 可变（线程安全） since JDK1.0<br>java.lang.StringBuffer public final class StringBuffer</p>
<p>StringBuilder 可变（非线程安全）since JDK1.5<br>java.lang.StringBuilder public final class StringBuilder</p>
</blockquote>
<p>关于StringBuffer，这里就先不贴源码了，需要记住的点是：</p>
<ol>
<li>StringBuffer和StringBuilder一样是<strong>可变</strong>的。大规模拼接效率高于String。</li>
<li>相较于StringBuilder的线程不安全，<strong>StringBuffer是线程安全的</strong>。多用于并发编程的场景。</li>
<li>线程安全是要有内存和效率上的代价的。具体是加锁的开销。</li>
</ol>
<p>归纳成一句，就是<strong>StringBuffer和StringBuilder一样都是String的辅助类。但StringBuilder是适用于单线程的轻量级版，StringBuffer是用于并发场景的重量级版。</strong></p>
<p>最后贴一个StringBuilder和StringBuffer直接的PK。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuilder拼接：415360纳秒</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">    sb.append(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuilder拼接：810470纳秒</span></span><br><span class="line">StringBuffer sbf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">    sbf.append(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<ul>
<li>StringBuilder拼接：    415360        纳秒</li>
<li>StringBuffer拼接：        810470        纳秒</li>
</ul>
<p>StringBuilder比StringBuffer快了近一倍。</p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>格式化输出，这个功能还是会很实用的。内存终归是有限的，实际工作中大量的数据是记录在外部文件里的，在学校的时候，经常跑一个实验就用到几百个G，甚至几个TB的样本数据。所以格式化输出的意义不是看打印出来漂不漂亮，而是在于让储存在外部文件里的数据更适于批量处理和读写。</p>
<p>Java里有三个类提供了格式化输出功能，也就是format()方法。他们都接受相同的参数来格式化输出。</p>
<ol>
<li>第一个：<strong>System.out.format()</strong>和<strong>System.out.printf()</strong>。这两个是等价的。</li>
<li>第二个：<strong>Formatter#format()</strong>。</li>
<li>第三个：<strong>String#format()</strong>。接受的参数和前两个一样。不同是会返回格式化的String型。但这个方法的好处是，它是String的静态方法，不用创建实例，比较方便。打印规模小的可以考虑用这个。</li>
</ol>
<h4 id="格式化语法"><a href="#格式化语法" class="headerlink" title="格式化语法"></a>格式化语法</h4><p>一般在控制台输出点东西，这样简单的使用场景，会写这样的格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Row 1: ["</span>+x+<span class="string">" "</span>+y+<span class="string">" "</span>+z+<span class="string">"]\n"</span>);</span><br><span class="line">System.out.printf(<span class="string">"Row 1: [%d %f %s]\n"</span>, x, y, z);</span><br><span class="line">System.out.format(<span class="string">"Row 1: [%d %f %s]\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure></p>
<p>这里，<strong>%d</strong>和<strong>%f</strong>和<strong>%s</strong>叫<strong>占位符</strong>，表示x插入%d的位置，y插入%f的位置，z插入%s的位置。%d表示数据转换成整型输出，%f表示数据转换成浮点型，%s表示数据转换成String型。</p>
<p>但这只是很简单的使用场景，虽然能用，但功能有限。完整的格式化语法是下面这个样子：</p>
<blockquote>
<p><strong>(%[argument_index$][flags][width][.precision][conversion], arg1, arg2, arg3, …)</strong></p>
</blockquote>
<p>其中每个位置分别表示：</p>
<ul>
<li><strong>argument_index</strong>: 一个正整数。标明是第几个参数。<strong>“1$”</strong>表示第一个参数arg1, <strong>“2$”</strong>表示第二个参数arg2，以此类推。</li>
<li><strong>flags</strong>: 格式符。比较常用的几个是：”-“表示左对齐。” “空格表示右对齐，前面用空格填满。”0”右对齐，前面用0填满。</li>
<li><strong>width</strong>: 一个正整数。表示这个域的最小尺寸。不足用空格来补。</li>
<li><strong>precision</strong>: 精度。对不同数据类型的意义不同。对String表示字符串的最大长度。对float和double则表示小数部分有几位。</li>
<li><strong>conversion</strong>: 转换成什么数据类型来输出。之前的%d这样的占位符，其实就是中间其他参数省略的结果，最后的conversion直接跟在%后面。</li>
</ul>
<p>下图是常用的flags格式符<br><img src="/uploads/tij4-13/flags.png" alt="flags"><br>下图是常用的conversion数据类型<br><img src="/uploads/tij4-13/conversion.png" alt="conversion"></p>
<h4 id="小练习：发票"><a href="#小练习：发票" class="headerlink" title="小练习：发票"></a>小练习：发票</h4><p>下面用一个例子实际演示怎么使用格式化语法。下面代码用于打出和书上一样的小发票。<br><img src="/uploads/tij4-13/receipt.png" alt="receipt"></p>
<p>代码里用的是Formatter#format()，其实无论换成System.out.format()或者System.out.printf()，再或者String#format()效果都是一样的。下面是代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receipt</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  PUBLIC METHODS</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3.3s %3$10.10s\n"</span>,<span class="string">"Item"</span>,<span class="string">"Qty"</span>,<span class="string">"Price"</span>);</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3.3s %3$10.10s\n"</span>,<span class="string">"----"</span>,<span class="string">"---"</span>,<span class="string">"-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String name, <span class="keyword">int</span> qty, <span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3d %3$10.2f\n"</span>,name,qty,price);</span><br><span class="line">        total+=price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3s %3$10.2f\n"</span>,<span class="string">"Tax"</span>, <span class="string">""</span>, total*<span class="number">0.15</span>);</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3s %3$10.10s\n"</span>,<span class="string">""</span>, <span class="string">""</span>,<span class="string">"-----"</span>);</span><br><span class="line">        f.format(<span class="string">"%1$-20.15s %2$3s %3$10.2f\n"</span>,<span class="string">"Total"</span>, <span class="string">""</span>,total*<span class="number">1.15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  PRIVATE FIELDS</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Formatter f=<span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  MAIN</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Receipt r=<span class="keyword">new</span> Receipt();</span><br><span class="line">        r.printTitle();</span><br><span class="line">        r.print(<span class="string">"Jack’s Magic Beans"</span>, <span class="number">4</span>, <span class="number">4.25</span>);</span><br><span class="line">        r.print(<span class="string">"Princess Peas"</span>, <span class="number">3</span>, <span class="number">5.1</span>);</span><br><span class="line">        r.print(<span class="string">"Three Bears Porridge"</span>, <span class="number">1</span>, <span class="number">14.29</span>);</span><br><span class="line">        r.printTotal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单举例解释<strong>“%1$-20.15s”</strong>这一段中：</p>
<ul>
<li><strong>“%”</strong>: 开头。 告诉编译器下面这段是格式语句。</li>
<li><strong>“1$”</strong>: [argument_index$]。 表示使用后面三个参数中的第一个。</li>
<li><strong>“-“</strong>: [flags]。表示不用默认的右对齐，而是左对齐。</li>
<li><strong>“20”</strong>: [width]。表示这段长度保持为20。不够用空格补满。</li>
<li><strong>“.15”</strong>: [.precision]。表示String的长度最多为15，超过的不打印。</li>
<li><strong>“s”</strong>: [conversion]。表示数据是String型。</li>
</ul>
<p>打印出来的效果就和上面书上的小发票的图一模一样。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>最后是这一章的一个大头，正则表达式。有多重要呢？如果不牢牢掌握的话，都不好意思说自己是程序员吧？写正则表达式，同一个意思可以有很多种写法，需要掌握一个原则：<strong>不是要写最花哨的表达式，而是写最简单，最好理解的表达式，只要足够完成任务就行。</strong></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>语法因为比较复杂，这里不可能完整地复制过来。只挑比较重要的列出来。完整的语法定义参见<a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" target="_blank" rel="external"><strong>“java.util.regex.Pattern”类的官方文档</strong></a>。里面有最权威的描述。再想深入学，可以读Friedl的《精通正则表达式-第3版》。</p>
<p>正则表达式最常用到的符号就是三个表示数量的符号了：</p>
<ul>
<li><strong>?</strong>：    一段字符，出现<strong>零次或一次</strong>。</li>
<li><em>：    一段字符，出现<em>*零次或一次或多次</em></em>。就是不管出现不出现，也不管出现多少次。</li>
<li><strong>+</strong>：    一段字符，至少出现<strong>一次或多次</strong>。就是出现至少一次。</li>
<li><strong>{n}</strong>：    一段字符，准确地出现<strong>n</strong>次。</li>
<li><strong>{n,}</strong>：    一段字符，至少出现<strong>n</strong>次。</li>
<li><strong>{n,m}</strong>：    一段字符，至少出现<strong>n</strong>次，但至最多出现<strong>m</strong>次。</li>
</ul>
<p>这些表示数量的符号要结合表示<strong>“字符”</strong>的符号一起使用。正则表达式语法里定义了很多，举几个最常用的例子：</p>
<ul>
<li><strong>1</strong>：    正常阿拉伯数字，就表示它本身。</li>
<li><strong>x</strong>：    正常英语字母，就表示他们本身。</li>
<li><strong>.</strong>：    任意字符</li>
<li><strong>\d</strong>：    任意一个[0-9]的阿拉伯数字。</li>
<li><strong>\D</strong>：    除了[0-9]数字之外的其他所有字符。</li>
<li><strong>\s</strong>：    一个空白符。包括[ \t\n\x0B\f\r]这些。这个真的很好用。</li>
<li><strong>\S</strong>：    相反的除了空白符之外的所有字符。</li>
<li><strong>\w</strong>：    一个单词字符。就是英语大小写字母加阿拉伯数字零到九，注意还有一个下划线”_”也算在里面。[a-zA-Z_0-9]</li>
<li><strong>\W</strong>：    除了单词字符以外的全部其他字符。</li>
<li><strong>\b</strong>：    单词边界符。这比较神奇。只匹配一个单词的边界，不匹配任何字符。占零个长度。这里的单词，就是前面\w单词符的内容。</li>
<li><strong>\B</strong>：    判断不是单词边界。</li>
</ul>
<p>还有其他的一些格式符：</p>
<ul>
<li><strong>\t</strong>：    一个tab符。对应的ASKII码是：(‘\u0009’)</li>
<li><strong>\n</strong>：    一个换行符。对应的ASKII码是：(‘\u000A’)</li>
<li><strong>\r</strong>：    一个回车符。对应的ASKII码是：(‘\u000D’)</li>
<li><strong>\e</strong>：    一个空格符。对应的ASKII码是：(‘\u001B’)</li>
<li><strong>^</strong>：    行首符。必须在正则表达式的起始位置。</li>
<li><strong>$</strong>：    行尾符。也可以是文末符，表示一段文本的末尾。</li>
</ul>
<p>注意这里的一个<strong>反斜杠”\”</strong>是很重要的，代表一个<strong>“转义符”</strong>。因为后面的那些字母都有它们自身的意义，前面加个反斜杠转义符，就是说：不表示他们的常规意义了，现在开始表示它的特殊意义。就是这样。但如果用在想一个点（或者说是句号）<strong>“.”</strong>的前面，因为这个点”.”本身不代表一个“句号”，而是是代表任意字符，已经转意了，前面再加一个转义符，就是转回来表示它的字面意义：“一个句号”。</p>
<ul>
<li><strong>.</strong>：    需要转义，才代表一个“点”。</li>
<li><strong>\</strong>：    也需要转个义，两个反斜杠才是真的表示一个反斜杠。</li>
</ul>
<p>另外，方括号<strong>“[]”</strong>代表一个“或”集。代表里面的字符，任取其一</p>
<ul>
<li><strong>[abc]</strong>：    a或b或c。 </li>
<li><strong>[^abc]</strong>：    除了a,b,c之外的任意其他字符。这里”^”在括号里就是“异”符号。在正则表达式的开头就表示行首符。</li>
</ul>
<p>括号<strong>“()”</strong>和数学公式里一样，表示优先合并。每个用括号扩起来的都是一个“组”。这个在的Matcher#group()方法会用到，它专门返回正则表达式的第几个组。</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>转义符看上去很简单，两种情况：</p>
<ul>
<li>正常字符转成不正常字符：比如”\n”换行符，”\t”Tab符，”\r”回车符，”\0”空格符。</li>
<li>特殊字符转回成正常意义：比如”\’”单引号，”\””双引号。</li>
</ul>
<p>但还是要专门提一下。自己以前经常被坑。</p>
<p>首先单纯从正则表达式的角度讲，<strong>“.“</strong>表示一个“句号”。两个反斜杠<strong>“\“</strong>表示一个正常反斜杠。都很好理解。</p>
<p>但在Java里，真的要用字符串表示一个句号”.”，要用<strong>“\.”</strong>。反斜杠”\”，要用<strong>“\\“</strong>来表示。吃过很多次亏。</p>
<p>这到底是为什么呢？简单讲是因为：正巧Java语言里，反斜杠<strong>“\”</strong>也是作为转义符存在，而我们在.java文件里的一个字符串String在被理解成正则表达式之前，要经过Java编译器，和正则表达式编译器的两次翻译。</p>
<h5 id="第一次翻译：Java编译器。"><a href="#第一次翻译：Java编译器。" class="headerlink" title="第一次翻译：Java编译器。"></a>第一次翻译：Java编译器。</h5><p>对Java编译器来讲，单个反斜杠”\”是个特殊字符。和正则表达式里一样，也是“转义符”。是用来转义其他所有特殊字符。悲剧由此开始。</p>
<p>所以要让Java编译器认出一个正常意义的反斜杠，就需要转义他自己：”\“两个反斜杠表示这是一个反斜杠。</p>
<h5 id="第二次翻译：正则表达式编译器。"><a href="#第二次翻译：正则表达式编译器。" class="headerlink" title="第二次翻译：正则表达式编译器。"></a>第二次翻译：正则表达式编译器。</h5><p>经过java编译器翻译的内容，会交到正则编译器手里。不幸在这里反斜杠又是转义符，要让要想让正则表达式编译器读出一个反斜杠，要对正则编译器说”\“。</p>
<p>那怎么才能把两个反斜杠”\“交到正则编译器手里呢？</p>
<p>对了，就要交给java编译器四个反斜杠”\\“，翻译成两个反斜杠”\“之后交到正则编译器手里，再第二次翻译成一个反斜杠”\”。</p>
<p>这叫什么？这就是贪污啊。把反斜杠看成是金条。我要是想交给正则表达式匹配函数一根金条，就要交给java编译器四根金条，贪污掉一半，剩两条交给正则表达式编译器，再贪污掉一半，最后剩的这根才交到表达式函数手里。</p>
<p>对一个句号”.”也是一样，”\.”给Java编译器，贪污一个反斜杠以后，交到正则编译器手里的时候剩一个反斜杠：”.“。然后正则编译器再贪污一遍，翻译成了”.”。</p>
<h3 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h3><p>Java里使用正则表达式，主要通过两个地方： </p>
<ul>
<li>第一，String对象的很多方法就能直接用。</li>
<li>第二，java.util.regex包里的Pattern类和Matcher类配合起来使用，功能更强大。</li>
</ul>
<h4 id="String对象使用正则表达式"><a href="#String对象使用正则表达式" class="headerlink" title="String对象使用正则表达式"></a>String对象使用正则表达式</h4><p>String里用正则表达式的方法有常用的<strong>matches(String regex)</strong>, 替换<strong>replaceFirst(String regex, String replacement)</strong>, <strong>replaceAll(String regex, String replacement)</strong>，切割<strong>split(String regex)</strong>。参数里的regex就代表着这个参数接受Sting形式的正则表达式。比如像下面这个例子，可以直接拿字符串去和一个正则表达式匹配。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello world"</span>.match(<span class="string">"(?i)((^[aeiou])|(\\s+[aeiou]))\\w+?[aeiou]\\b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: false</span></span><br></pre></td></tr></table></figure></p>
<p>上面例子里的正则表达式，翻译成人话就是：一个以元音(aeiou)开头，元音结尾的单词。其中(?i)表示一种匹配策略CASE_INSENSITIVE，忽略所有大小写。在Pattern和Matcher类里也有这个功能。然后明显hello和word都不是元音开头，所以返回false。</p>
<h4 id="Pattern-amp-Matcher"><a href="#Pattern-amp-Matcher" class="headerlink" title="Pattern &amp; Matcher"></a>Pattern &amp; Matcher</h4><p>另外，在java.util.regex包里的<strong>Pattern</strong>类和<strong>Matcher</strong>类才是专门为正则表达式而生的类。</p>
<p>用法也很简单，Pattern.compile(String regex)方法可以把String形式的正则表达式编译成一个Pattern对象。然后Pattern#matcher(String str)方法通过给Pattern对象传递一个需要匹配的字符串，返回一个Matcher对象。可以调用Matcher类的各种方法，比如Matcher#split()以及Matcher#replaceAll()。</p>
<h5 id="Matcher-find"><a href="#Matcher-find" class="headerlink" title="Matcher#find( )"></a>Matcher#find( )</h5><p>public boolean Matcher#find()尝试查找与该模式匹配的输入序列的下一个子序列。此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。  </p>
<ul>
<li>matcher.start() 返回匹配到的子字符串在字符串中的索引位置. </li>
<li>matcher.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. </li>
<li>matcher.group()返回匹配到的子字符串 </li>
</ul>
<p>当且仅当输入序列的子序列匹配此匹配器的模式时才返回 true。</p>
<h5 id="Matcher-matches"><a href="#Matcher-matches" class="headerlink" title="Matcher#matches( )"></a>Matcher#matches( )</h5><p>public boolean Matcher#matches()尝试对整个目标字符串进行正则匹配，只有当整个字符串完整匹配，才返回true。</p>
<p>而且，在Pattern类里有一个相同功能的静态方法Pattern.matches()。不用创建Pattern和Matcher对象适合小规模零散正则匹配。如果要多次使用一种模式，编译一次生成Pattern对象，重用此模式比每次都调用此方法效率更高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex,  CharSequence input)</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Pattern.<span class="title">matches</span><span class="params">(regex, input)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="Matcher-lookingAt"><a href="#Matcher-lookingAt" class="headerlink" title="Matcher#lookingAt( )"></a>Matcher#lookingAt( )</h5><p>和find()和matches()方法类似，也是匹配目标字符串和正则表达式。不同点是lookingAt()是从目标字符串的开头开始找有没有能匹配正则表达式的一个子串。比如下面这个例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"reg"</span>);</span><br><span class="line">Matcher m=p.matcher(<span class="string">"regular"</span>);</span><br><span class="line">System.out.println(m.lookingAt());</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: true</span></span><br></pre></td></tr></table></figure></p>
<p>单词regular的开头包含reg子串，所以匹配成功。</p>
<h5 id="组"><a href="#组" class="headerlink" title="组"></a>组</h5><p>之前讲过，正则表达式用括号括起来的部分都是一个“组”。每个组在正则表达式里，都有自己的序号。序号是这样定义的：<br>假设有<strong>“A(B(C))D”</strong>这个正则表达式，一共有三个组：</p>
<ul>
<li>Group 0：就是全体”ABCD” </li>
<li>Group 1：就是左起第一个括号里的内容”BC”</li>
<li>Group 2：是左起第二个括号里的”C”</li>
</ul>
<p>如果上面的find(),matches(),lookingAt()方法，匹配成功的话，调用Matcher#group()无参数方法，可以返回序号是0的组，也就是全体。Matcher#group(int i)方法就返回对应序号的组。</p>
<h4 id="appendReplacement-StringBuffer-sbuf-String-replacement-和appendTail-StringBuffer-sbuf"><a href="#appendReplacement-StringBuffer-sbuf-String-replacement-和appendTail-StringBuffer-sbuf" class="headerlink" title="appendReplacement(StringBuffer sbuf, String replacement)和appendTail(StringBuffer sbuf)"></a>appendReplacement(StringBuffer sbuf, String replacement)和appendTail(StringBuffer sbuf)</h4><p>正常情况下，如果每次替换的内容都一样，appendReplacement()其实和replaceAll()的效果一样。但appendReplacement()的优势是渐进式替换，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">   m.appendReplacement(sbuf, m.group().toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.appendTail(sbuf);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码每次用的都是大写替换小写m.group().toUpperCase()。但因为可以调用一个函数来生成替换内容，这部分我们可以在里面做很大的文章，设计成每次特换不同的内容。</p>
<h4 id="Matcher-reset"><a href="#Matcher-reset" class="headerlink" title="Matcher#reset( )"></a>Matcher#reset( )</h4><p>reset()方法可以将现有Matcher应用于一个新的字符串。这样就可以重复使用构造好的某个pattern。效率更高。例子如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"reg"</span>);</span><br><span class="line">Matcher m=p.matcher(<span class="string">"regular"</span>);</span><br><span class="line">System.out.println(m.lookingAt());</span><br><span class="line"></span><br><span class="line"><span class="comment">//不换表达式"reg"，直接换一段目标字符串来匹配。</span></span><br><span class="line">m.reset(<span class="string">"expression"</span>);</span><br><span class="line">System.out.println(m.lookingAt());</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中的m.reset(“expression”)在不换正则表达式”reg”的情况下，直接换一段目标字符串来匹配。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正则表达式很重要，需要以后在工作中熟练操作。</p>
<p>String很底层，和虚拟机结合地很深。里面有很多学问。越是常见基本的东西，越是容易被人忽视。但其中往往有大乾坤。</p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/regular-expression/" rel="tag">#regular expression</a>
          
            <a href="/tags/string/" rel="tag">#string</a>
          
            <a href="/tags/字符串/" rel="tag">#字符串</a>
          
            <a href="/tags/标准化输出/" rel="tag">#标准化输出</a>
          
            <a href="/tags/正则表达式/" rel="tag">#正则表达式</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/17/tij4-12/" rel="next" title="Think in Java 读书笔记：第十二章 - 异常控制">
                <i class="fa fa-chevron-left"></i> Think in Java 读书笔记：第十二章 - 异常控制
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/29/string/" rel="prev" title="String str=new String("Hello")到底创建了几个对象？">
                String str=new String("Hello")到底创建了几个对象？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/25/tij4-13/"
           data-title="Think in Java 读书笔记：第十三章 - 字符串" data-url="www.ciaoshen.com/2016/07/25/tij4-13/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/shenAvatar.jpg"
               alt="沈玮 | Wei SHEN" />
          <p class="site-author-name" itemprop="name">沈玮 | Wei SHEN</p>
          <p class="site-description motion-element" itemprop="description">Coder & Designer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">116</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/helloShen" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.douban.com/people/72441576/" target="_blank">
                  
                    <i class="fa fa-globe"></i> DouBan
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/pang-pang-37-37" target="_blank">
                  
                    <i class="fa fa-globe"></i> ZhiHu
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">2.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String到底是个什么？"><span class="nav-number">3.</span> <span class="nav-text">String到底是个什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String是不可变的，线程安全的"><span class="nav-number">4.</span> <span class="nav-text">String是不可变的，线程安全的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是不可变？"><span class="nav-number">4.1.</span> <span class="nav-text">什么是不可变？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么String是不可变的？"><span class="nav-number">4.2.</span> <span class="nav-text">为什么String是不可变的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可变有什么好处？"><span class="nav-number">4.3.</span> <span class="nav-text">不可变有什么好处？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String常量池"><span class="nav-number">5.</span> <span class="nav-text">String常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变特性影响了String的效率"><span class="nav-number">6.</span> <span class="nav-text">不可变特性影响了String的效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更高效的字符串构造工具StringBuilder"><span class="nav-number">6.1.</span> <span class="nav-text">更高效的字符串构造工具StringBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单的String拼接真的这么慢吗？"><span class="nav-number">6.2.</span> <span class="nav-text">简单的String拼接真的这么慢吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环的时候，注意手动在循环外创建一个StringBuilder"><span class="nav-number">6.3.</span> <span class="nav-text">循环的时候，注意手动在循环外创建一个StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-V-s-StringBuilder-V-s-StringBuffer"><span class="nav-number">7.</span> <span class="nav-text">String V.s. StringBuilder V.s. StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输出"><span class="nav-number">8.</span> <span class="nav-text">格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化语法"><span class="nav-number">8.1.</span> <span class="nav-text">格式化语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小练习：发票"><span class="nav-number">8.2.</span> <span class="nav-text">小练习：发票</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">9.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语法"><span class="nav-number">9.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转义符"><span class="nav-number">9.2.</span> <span class="nav-text">转义符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一次翻译：Java编译器。"><span class="nav-number">9.2.1.</span> <span class="nav-text">第一次翻译：Java编译器。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二次翻译：正则表达式编译器。"><span class="nav-number">9.2.2.</span> <span class="nav-text">第二次翻译：正则表达式编译器。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式的应用"><span class="nav-number">10.</span> <span class="nav-text">正则表达式的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String对象使用正则表达式"><span class="nav-number">10.1.</span> <span class="nav-text">String对象使用正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pattern-amp-Matcher"><span class="nav-number">10.2.</span> <span class="nav-text">Pattern & Matcher</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Matcher-find"><span class="nav-number">10.2.1.</span> <span class="nav-text">Matcher#find( )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Matcher-matches"><span class="nav-number">10.2.2.</span> <span class="nav-text">Matcher#matches( )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Matcher-lookingAt"><span class="nav-number">10.2.3.</span> <span class="nav-text">Matcher#lookingAt( )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组"><span class="nav-number">10.2.4.</span> <span class="nav-text">组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#appendReplacement-StringBuffer-sbuf-String-replacement-和appendTail-StringBuffer-sbuf"><span class="nav-number">10.3.</span> <span class="nav-text">appendReplacement(StringBuffer sbuf, String replacement)和appendTail(StringBuffer sbuf)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Matcher-reset"><span class="nav-number">10.4.</span> <span class="nav-text">Matcher#reset( )</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沈玮 | Wei SHEN</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io" rel="external nofollow">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Mist
  </a>
</div>

</br>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div>
  <span id="busuanzi_container_site_pv">
  Visited  <span id="busuanzi_value_site_pv"></span>  times
  </span>

<span id="busuanzi_container_site_pv">&nbsp; &nbsp; | &nbsp; &nbsp;</span>

  <span id="busuanzi_container_site_uv">
  <span id="busuanzi_value_site_uv"></span>  Visitors
  </span>
<div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ciaoshen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  





  
  

  
  


</body>
</html>
